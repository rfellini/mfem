// Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at
// the Lawrence Livermore National Laboratory. LLNL-CODE-443211. All Rights
// reserved. See file COPYRIGHT for details.
//
// This file is part of the MFEM library. For more information and source code
// availability see http://mfem.org.
//
// MFEM is free software; you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License (as published by the Free
// Software Foundation) version 2.1 dated February 1999.

#include "occa://mfem/fem/defines.okl"

//---[ 1D ]-----------------------------
kernel void Assemble1D(const int numElements,
                       const double * restrict quadWeights,
                       const Jacobian1D_t restrict J,
                       const Coeff_t coeff,
                       ScalarOperator1D_t restrict oper) {
   for (int e = 0; e < numElements; ++e; outer) {
      for (int q = 0; q < NUM_QUAD_1D; ++q; inner) {
         oper(q, e) = quadWeights[q] * COEFF(q, e) * J(q, e);
      }
   }
}

kernel void Mult1D(const int numElements,
                   const DofToQuad_t restrict dofToQuad,
                   const DofToQuad_t restrict dofToQuadD,
                   const QuadToDof_t restrict quadToDof,
                   const QuadToDof_t restrict quadToDofD,
                   const ScalarOperator1D_t restrict oper,
                   Local1D_t restrict sol) {
   // Iterate over elements
   for (int e = 0; e < numElements; ++e; outer) {
      for (int dummy = 0; dummy < 1; ++dummy; inner) {
         double solq[NUM_QUAD_1D];
         for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            solq[qx] = 0;
         }
         // solq{qx} = dofToQuad{qx,dx} * sol{dx}
         for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            const double s = sol(dx, e);
            sol(dx, e) = 0;
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
               solq[qx] += s * dofToQuad(qx, dx);
            }
         }
         // solq{q} *= oper{q}
         for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            solq[qx] *= oper(qx, e);
         }
         // sol{dx} = quadToDof{dx,qx} * solq{qx}
         for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
               sol(dx, e) += solq[qx] * quadToDof(dx, qx);
            }
         }
      }
   }
}
//======================================


//---[ 2D ]-----------------------------
kernel void Assemble2D(const int numElements,
                       const double * restrict quadWeights,
                       const Jacobian2D_t restrict J,
                       const Coeff_t coeff,
                       ScalarOperator2D_t restrict oper) {
   for (int e = 0; e < numElements; ++e; outer) {
      for (int q = 0; q < NUM_QUAD_2D; ++q; inner) {
         const double J11 = J(0, 0, q, e), J12 = J(1, 0, q, e);
         const double J21 = J(0, 1, q, e), J22 = J(1, 1, q, e);

         oper(q, e) = quadWeights[q] * COEFF(q, e) * ((J11 * J22) - (J21 * J12));
      }
   } // e
}

kernel void Mult2D(const int numElements,
                   const DofToQuad_t restrict dofToQuad,
                   const DofToQuad_t restrict dofToQuadD,
                   const QuadToDof_t restrict quadToDof,
                   const QuadToDof_t restrict quadToDofD,
                   const ScalarOperator2D_t restrict oper,
                   Local2D_t restrict sol) {
   // Iterate over elements
   for (int e = 0; e < numElements; ++e; outer) {
      for (int dummy=0; dummy<1; ++dummy; inner) {
         double solqq[NUM_QUAD_1D][NUM_QUAD_1D];

         for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
               solqq[qx][qy] = 0;
            }
         }

         for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
            double solq[NUM_QUAD_1D];
            for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
               solq[qy] = 0;
            }

            // solq{dx, qy} = dofToQuad{qy, dy} * sol{dx, dy}
            for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
               const double s = sol(dx, dy, e);
               sol(dx, dy, e) = 0;
               for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
                  solq[qy] += dofToQuad(qy, dx) * s;
               }
            }

            // solqq{qx, qy} = dofToQuad{qx, dx} * solq{dx, qy}
            for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
               const double d2q = dofToQuad(qy, dy);
               for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                  solqq[qx][qy] += d2q * solq[qx];
               }
            }
         } // dy

         // solqq{qx, qy} = solqq{q} *= oper{q, e}
         for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
               const int q = QUAD_2D_ID(qx, qy);
               solqq[qx][qy] *= oper(q, e);
            }
         }

         for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
            double solq[NUM_DOFS_1D];
            for (int dx = 0; dx < NUM_QUAD_1D; ++dx) {
               solq[dx] = 0;
            }

            // solq{qx, dy} = quadToDof{dy, qy} * solqq{qx, qy}
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
               const double s = solqq[qx][qy];
               for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                  solq[dx] += quadToDof(dx, qx) * s;
               }
            }

            // sol{dx, dy, e} = quadToDof{dx, qx} * solq{qx, dy}
            for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
               const double q2d = quadToDof(dy, qy);
               for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                  sol(dx, dy, e) += q2d * solq[dx];
               }
            }
         }
      } // dummy
   } // e
}
//======================================


//---[ 3D ]-----------------------------
kernel void Assemble3D(const int numElements,
                       const double * restrict quadWeights,
                       const Jacobian3D_t restrict J,
                       const Coeff_t coeff,
                       ScalarOperator3D_t restrict oper) {
   for (int e = 0; e < numElements; ++e; outer) {
      for (int q = 0; q < NUM_QUAD_3D; ++q; inner) {
         const double J11 = J(0, 0, q, e), J12 = J(1, 0, q, e), J13 = J(2, 0, q, e);
         const double J21 = J(0, 1, q, e), J22 = J(1, 1, q, e), J23 = J(2, 1, q, e);
         const double J31 = J(0, 2, q, e), J32 = J(1, 2, q, e), J33 = J(2, 2, q, e);

         const double detJ = ((J11 * J22 * J33) + (J12 * J23 * J31) + (J13 * J21 * J32) -
                              (J13 * J22 * J31) - (J12 * J21 * J33) - (J11 * J23 * J32));

         oper(q, e) = quadWeights[q] * COEFF(q, e) * detJ;
      }
   }
}

kernel void Mult3D(const int numElements,
                   const DofToQuad_t restrict dofToQuad,
                   const DofToQuad_t restrict dofToQuadD,
                   const QuadToDof_t restrict quadToDof,
                   const QuadToDof_t restrict quadToDofD,
                   const ScalarOperator3D_t restrict oper,
                   Local3D_t restrict sol) {
   // Iterate over elements
   for (int e = 0; e < numElements; ++e; outer) {
      for (int dummy = 0; dummy < 1; ++dummy; inner) {
         double solqqq[NUM_QUAD_1D][NUM_QUAD_1D][NUM_QUAD_1D];
         for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
            for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
               for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                  solqqq[qz][qy][qx] = 0;
               }
            }
         }

         for (int dz = 0; dz < NUM_DOFS_1D; ++dz) {
            double solqq[NUM_QUAD_1D][NUM_QUAD_1D];
            for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
               for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                  solqq[qy][qx] = 0;
               }
            }

            for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
               double solq[NUM_QUAD_1D];
               for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                  solq[qx] = 0;
               }

               // solq{qx} = dofToQuad{qx, dx} * sol{dx, dy, dz, e}
               for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                  const double s = sol(dx, dy, dz, e);
                  sol(dx, dy, dz, e) = 0;
                  for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                     solq[qx] += dofToQuad(qx, dx) * s;
                  }
               }

               // solqq{qx, qy} = dofToQuad{qy, dy} * solq{dx}
               for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
                  const double d2q = dofToQuad(qy, dy);
                  for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                     solqq[qy][qx] += dofToQuad(qy, dy) * solq[qx];
                  }
               }
            } // dy

            for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
               const double d2q = dofToQuad(qz, dz);
               for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
                  for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                     solqqq[qz][qy][qx] += d2q * solqq[qy][qx];
                  }
               }
            }
         } // dz

         // solqqq{qz, qy, qx} *= oper{q, e}
         for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
            for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
               for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                  const int q = QUAD_3D_ID(qx, qy, qz);
                  solqqq[qz][qy][qx] *= oper(q, e);
               }
            }
         }

         for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
            double solqq[NUM_DOFS_1D][NUM_DOFS_1D];
            for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
               for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                  solqq[dy][dx] = 0;
               }
            }

            for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
               double solq[NUM_DOFS_1D];
               for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                  solq[dx] = 0;
               }

               // solq{dx} = quadToDof{dx, qx} * solqqq{qz, qy, qx}
               for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
                  const double s = solqqq[qz][qy][qx];
                  for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                     solq[dx] += quadToDof(dx, qx) * s;
                  }
               }

               // solqq{dy, dx} = quadToDof{dy, qy} * solq{dx}
               for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
                  const double q2d  = quadToDof(dy, qy);
                  for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                     solqq[dy][dx] += solq[dx] * q2d;
                  }
               }
            } // qy

            for (int dz = 0; dz < NUM_DOFS_1D; ++dz) {
               const double q2d = quadToDof(dz, qz);
               for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
                  for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
                     sol(dx, dy, dz, e) += q2d * solqq[dy][dx];
                  }
               }
            }
         } // qz
      } // dummy
   } // e
   
}
//======================================
